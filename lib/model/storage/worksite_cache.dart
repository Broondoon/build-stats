import 'dart:collection';
import 'dart:convert';
import 'package:build_stats_flutter/model/Domain/ServiceInterface/data_connection_service.dart';
import 'package:build_stats_flutter/model/entity/worksite.dart';
import 'package:build_stats_flutter/model/Domain/ServiceInterface/cache_service.dart';
import 'package:build_stats_flutter/model/storage/data_sync/data_connection.dart';
import 'package:build_stats_flutter/model/storage/local_storage/file_access.dart';
import 'package:build_stats_flutter/model/storage/checklist_cache.dart';
import 'package:build_stats_flutter/resources/app_strings.dart';
import 'package:localstorage/localstorage.dart';

class WorksiteCache implements CacheService<Worksite> {
  final DataConnectionService<Worksite> _dataConnectionService;
  WorksiteCache(this._dataConnectionService);

  @override
  Future<Worksite?> getById(String key) async {
    Worksite? worksite;
    String? worksiteJson = localStorage.getItem(key);
    if (worksiteJson != null) {
      worksite = Worksite.fromJson(jsonDecode(worksiteJson));
    } else {
      worksite = await LoadWorksiteById(key);
    }
    return worksite;
  }

  @override
  Future<void> delete(String key) {
    // TODO: implement delete
    throw UnimplementedError();
  }

  @override
  Future<Worksite> load(String key) {
    // TODO: implement load
    throw UnimplementedError();
  }

  @override
  Future<void> save(String key, value) {
    // TODO: implement save
    throw UnimplementedError();
  }

  @override
  Future<void> store(String key, value) {
    // TODO: implement store
    throw UnimplementedError();
  }

  //Below should be entirly internal, and not for Frontend use

  static Future<List<Worksite>> _getWorksites() async {
    List<Worksite> worksites = [];
    if (!(await DataConnection.CheckConnection())) {
      String jsonString = await FileAccess.ReadJsonDataFile(WorksiteFileString);
      if (jsonString.isNotEmpty) {
        List<dynamic> jsonData = jsonDecode(jsonString);
        worksites = jsonData.map((json) => Worksite.fromJson(json)).toList();
      }
    }
    return worksites;
  }

  //Initially Generated by CHATGPT
  static Future<Worksite?> LoadWorksiteById(String id) async {
    List<Worksite> worksites = await _getWorksites();

    if (worksites.isEmpty) {
      return null;
    }

    // Traverse the hierarchy to find the Worksite with the given ID
    for (Worksite worksite in worksites) {
      if (localStorage.getItem(worksite.id) == null) {
        localStorage.setItem(worksite.id, jsonEncode(worksite.toJson()));
      }
      if (worksite.id == id) {
        return worksite;
      }
    }
    // If the item is not found, return null
    return null;
  }

  static Future<Null> StoreWorksite(Worksite worksite) async {
    localStorage.setItem(worksite.id, jsonEncode(worksite.toJson()));
    await SaveWorksite(worksite);
  }

  //Initially Generated by CHATGPT
  static Future<Null> SaveWorksite(Worksite worksite) async {
    List<Worksite> worksites = await _getWorksites();

    // Flag to check if the worksite was saved
    // Traverse the hierarchy to find where to save the worksite
    int worksiteIndex = worksites.indexWhere((i) => i.id == worksite.id);
    if (worksiteIndex != -1) {
      worksites[worksiteIndex] = worksite;
    } else {
      worksites.add(worksite);
    }
    // Encode the worksites back to JSON and save to the file
    String updatedJson =
        jsonEncode(worksites.map((worksite) => worksite.toJson()).toList());
    await FileAccess.SaveDataFile(WorksiteFileString, updatedJson);
  }

  @override
  Future<HashMap<String, String>> getCacheCheckSums() {
    // TODO: implement getCacheCheckSums
    throw UnimplementedError();
  }
}
