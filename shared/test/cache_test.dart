// cache_test.dart

import 'package:test/test.dart';
import 'dart:collection';
import 'dart:convert';
import 'package:mockito/mockito.dart';

// Import the Cache class and the necessary dependencies
import 'package:shared/src/base_entities/entity/entity.dart';
import 'package:shared/src/base_services/cache/cache.dart';

// Import the mocks generated by Mockito
import 'mocks.dart';

// Constants and enums used in the tests
const String ID_TempIDPrefix = 'temp_';

enum EntityState { deleted }

void main() {
  group('Cache Tests', () {
    late Cache<Entity> cache;
    late FakeLocalStorage localStorage;
    late TestReadWriteMutex mutex;
    late MockEntityFactory<Entity> entityFactory;

    setUp(() {
      localStorage = FakeLocalStorage();
      mutex = TestReadWriteMutex();
      entityFactory = MockEntityFactory<Entity>();
      cache = Cache<Entity>(entityFactory, localStorage, mutex, "");
    });

    test('Store and Get Entity', () async {
      // Create a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entityFactory.fromJson(any)).thenReturn(entity);

      // Store the entity
      await cache.store(entity.id, entity);

      // Retrieve the entity
      List<Entity>? entities =
          await cache.get([entity.id], (missingKeys) async {
        return null; // No cache miss handling in this test
      });

      expect(entities, isNotNull);
      expect(entities!.length, 1);
      expect(entities[0].id, entity.id);
    });

    test('Get with Cache Miss', () async {
      // Create a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entityFactory.fromJson(any)).thenReturn(entity);

      // Attempt to retrieve the entity
      List<Entity>? entities =
          await cache.get([entity.id], (missingKeys) async {
        // Simulate fetching missing entities and returning their JSON representation
        List<String> missingEntitiesJson = missingKeys!
            .map((key) => jsonEncode({'id': key, 'data': 'data$key'}))
            .toList();
        return missingEntitiesJson;
      });

      expect(entities, isNotNull);
      expect(entities!.length, 1);
      expect(entities[0].id, entity.id);

      List<Entity>? entities2 =
          await cache.get([entity.id], (missingKeys) async {
        return null;
      });

      expect(entities2, isNotNull);
      expect(entities2!.length, 1);
      expect(entities2[0].id, entity.id);
    });

    test('Delete Entity', () async {
      // Create and store a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});

      await cache.store(entity.id, entity);

      // Delete the entity
      await cache.delete(entity.id);

      // Ensure localStorage.removeItem was called
      //verify(localStorage.removeItem).called(1);

      List<Entity>? entities =
          await cache.get([entity.id], (missingKeys) async {
        return null;
      });

      expect(entities, isEmpty);
    });

    test('Get All Entities', () async {
      // Create and store mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');
      when(entity1.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entity2.toJson()).thenReturn({'id': '2', 'data': 'data2'});
      when(entityFactory.fromJson({'id': '1', 'data': 'data1'}))
          .thenReturn(entity1);
      when(entityFactory.fromJson({'id': '2', 'data': 'data2'}))
          .thenReturn(entity2);

      await cache.store(entity1.id, entity1);
      await cache.store(entity2.id, entity2);

      // Retrieve all entities
      List<Entity>? entities = await cache.getAll((missingKeys) async {
        return null;
      });

      expect(entities, isNotNull);
      expect(entities!.length, 2);
      expect(entities.any((e) => e.id == entity1.id), isTrue);
      expect(entities.any((e) => e.id == entity2.id), isTrue);
    });

    test('Store Bulk Entities', () async {
      // Create mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');
      when(entity1.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entity2.toJson()).thenReturn({'id': '2', 'data': 'data2'});
      when(entityFactory.fromJson({'id': '1', 'data': 'data1'}))
          .thenReturn(entity1);
      when(entityFactory.fromJson({'id': '2', 'data': 'data2'}))
          .thenReturn(entity2);

      // Store entities in bulk
      List<Entity> storedEntities = await cache.storeBulk([entity1, entity2]);

      expect(storedEntities.length, 2);

      // Retrieve entities
      List<Entity>? entities =
          await cache.get([entity1.id, entity2.id], (missingKeys) async {
        return null;
      });

      expect(entities, isNotNull);
      expect(entities!.length, 2);
      expect(entities.any((e) => e.id == entity1.id), isTrue);
      expect(entities.any((e) => e.id == entity2.id), isTrue);
    });

    

    test('Get Cache Check States', () async {
      // Create and store mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');
      when(entity1.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entity2.toJson()).thenReturn({'id': '2', 'data': 'data2'});

      await cache.store(entity1.id, entity1);
      await cache.store(entity2.id, entity2);

      Map<String, String> cacheCheckStates = await cache.getCacheCheckStates();

      expect(cacheCheckStates.length, 2);
      expect(cacheCheckStates[entity1.id], entity1.getChecksum());
      expect(cacheCheckStates[entity2.id], entity2.getChecksum());
    });
    test('Store Entity with Temp ID', () async {
      // Create a mock entity with temp ID
      final entity = MockEntity();
      final tempId = "${ID_TempIDPrefix}1";
      when(entity.id).thenReturn(tempId);
      when(entity.toJson()).thenReturn({'id': tempId, 'data': 'data1'});

      // Store the entity
      await cache.store(entity.id, entity);

      // Check that cacheCheckSums does not contain the temp ID
      Map<String, String> cacheCheckStates = await cache.getCacheCheckStates();
      expect(cacheCheckStates.containsKey(entity.id), isFalse);

      // cacheSyncFlags should be true
      expect(cache.cacheSyncFlags[entity.id], true);
    });

  });
}
