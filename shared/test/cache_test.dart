// cache_test.dart

import 'package:mutex/mutex.dart';
import 'package:test/test.dart';
import 'dart:collection';
import 'dart:convert';
import 'package:mockito/mockito.dart';

// Import the Cache class and the necessary dependencies
import 'package:shared/src/base_entities/entity/entity.dart';
import 'package:shared/src/base_services/cache/cache.dart';
import 'package:shared/src/base_services/cache/localStorage.dart';

// Import the mocks generated by Mockito
import 'mocks.dart';

// Constants and enums used in the tests
const String ID_TempIDPrefix = 'temp_';

enum EntityState { deleted }

void main() {
  group('Cache Tests', () {
    late Cache<Entity> cache;
    late FakeLocalStorage localStorage;
    late TestReadWriteMutex mutex;
    late MockEntityFactory<Entity> entityFactory;

    setUp(() {
      localStorage = FakeLocalStorage();
      mutex = TestReadWriteMutex();
      entityFactory = MockEntityFactory<Entity>();
      cache = Cache<Entity>(entityFactory, localStorage, mutex);
    });

    test('Store and Get Entity', () async {
      // Create a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entityFactory.fromJson(any)).thenReturn(entity);

      // Store the entity
      await cache.store(entity.id, entity);

      // Retrieve the entity
      List<Entity>? entities =
          await cache.get([entity.id], (missingKeys) async {
        return null; // No cache miss handling in this test
      });

      expect(entities, isNotNull);
      expect(entities!.length, 1);
      expect(entities[0].id, entity.id);
    });

    test('Get with Cache Miss', () async {
      // Create a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entityFactory.fromJson(any)).thenReturn(entity);

      // Attempt to retrieve the entity
      List<Entity>? entities =
          await cache.get([entity.id], (missingKeys) async {
        // Simulate fetching missing entities and returning their JSON representation
        List<String> missingEntitiesJson = missingKeys!
            .map((key) => jsonEncode({'id': key, 'data': 'data$key'}))
            .toList();
        return missingEntitiesJson;
      });

      expect(entities, isNotNull);
      expect(entities!.length, 1);
      expect(entities[0].id, entity.id);

      List<Entity>? entities2 =
          await cache.get([entity.id], (missingKeys) async {
        return null;
      });

      expect(entities2, isNotNull);
      expect(entities2!.length, 1);
      expect(entities2[0].id, entity.id);
    });

    test('Delete Entity', () async {
      // Create and store a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});

      await cache.store(entity.id, entity);

      // Delete the entity
      await cache.delete(entity.id);

      // Ensure localStorage.removeItem was called
      //verify(localStorage.removeItem).called(1);

      List<Entity>? entities =
          await cache.get([entity.id], (missingKeys) async {
        return null;
      });

      expect(entities, isEmpty);
    });

    test('Get All Entities', () async {
      // Create and store mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');
      when(entity1.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entity2.toJson()).thenReturn({'id': '2', 'data': 'data2'});
      when(entityFactory.fromJson({'id': '1', 'data': 'data1'}))
          .thenReturn(entity1);
      when(entityFactory.fromJson({'id': '2', 'data': 'data2'}))
          .thenReturn(entity2);

      await cache.store(entity1.id, entity1);
      await cache.store(entity2.id, entity2);

      // Set up localStorage keys and getItem
      when(localStorage.keys).thenReturn([entity1.id, entity2.id]);
      when(localStorage.getItem(entity1.id))
          .thenAnswer((_) async => jsonEncode(entity1.toJson()));
      when(localStorage.getItem(entity2.id))
          .thenAnswer((_) async => jsonEncode(entity2.toJson()));

      // Retrieve all entities
      List<Entity>? entities = await cache.getAll((missingKeys) async {
        return null;
      });

      expect(entities, isNotNull);
      expect(entities!.length, 2);
      expect(entities.any((e) => e.id == entity1.id), isTrue);
      expect(entities.any((e) => e.id == entity2.id), isTrue);
    });

    test('Store Bulk Entities', () async {
      // Create mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');
      when(entity1.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entity2.toJson()).thenReturn({'id': '2', 'data': 'data2'});
      when(entityFactory.fromJson({'id': '1', 'data': 'data1'}))
          .thenReturn(entity1);
      when(entityFactory.fromJson({'id': '2', 'data': 'data2'}))
          .thenReturn(entity2);

      // Store entities in bulk
      List<Entity> storedEntities = await cache.storeBulk([entity1, entity2]);

      expect(storedEntities.length, 2);

      // Set up localStorage getItem
      when(localStorage.getItem(entity1.id))
          .thenAnswer((_) async => jsonEncode(entity1.toJson()));
      when(localStorage.getItem(entity2.id))
          .thenAnswer((_) async => jsonEncode(entity2.toJson()));

      // Retrieve entities
      List<Entity>? entities =
          await cache.get([entity1.id, entity2.id], (missingKeys) async {
        return null;
      });

      expect(entities, isNotNull);
      expect(entities!.length, 2);
      expect(entities.any((e) => e.id == entity1.id), isTrue);
      expect(entities.any((e) => e.id == entity2.id), isTrue);
    });

    test('Set Cache Sync Flags', () async {
      // Create and store mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');
      when(entity1.toJson()).thenReturn({'id': '1', 'data': 'data1'});
      when(entity2.toJson()).thenReturn({'id': '2', 'data': 'data2'});

      await cache.store(entity1.id, entity1);
      await cache.store(entity2.id, entity2);

      // Set cache sync flags with different checksums
      HashMap<String, String> serverCheckSums = HashMap();
      serverCheckSums[entity1.id] = 'checksum1_modified'; // Different checksum
      serverCheckSums[entity2.id] = 'checksum2'; // Same checksum

      await cache.setCacheSyncFlags(serverCheckSums);

      // Check that cacheSyncFlags have been updated
      expect(cache.cacheSyncFlags[entity1.id], false);
      expect(cache.cacheSyncFlags[entity2.id], true);
    });

    test('Get Cache Check States', () async {
      // Create and store mock entities
      final entity1 = MockEntity();
      final entity2 = MockEntity();
      when(entity1.id).thenReturn('1');
      when(entity2.id).thenReturn('2');
      when(entity1.getChecksum()).thenReturn('checksum1');
      when(entity2.getChecksum()).thenReturn('checksum2');

      await cache.store(entity1.id, entity1);
      await cache.store(entity2.id, entity2);

      HashMap<String, String> cacheCheckStates =
          await cache.getCacheCheckStates();

      expect(cacheCheckStates.length, 2);
      expect(cacheCheckStates[entity1.id], entity1.getChecksum());
      expect(cacheCheckStates[entity2.id], entity2.getChecksum());
    });

    test('Store Unprotected Outside Write Lock Throws Exception', () async {
      // Create a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');

      // Unlock the mutex
      when(mutex.isWriteLocked).thenReturn(false);

      // Attempt to call storeUnprotected without a write lock
      expect(() async => await cache.storeUnprotected(entity.id, entity),
          throwsException);
    });

    test('Delete Unprotected Outside Write Lock Throws Exception', () async {
      // Unlock the mutex
      when(mutex.isWriteLocked).thenReturn(false);

      // Attempt to call deleteUnprotected without a write lock
      expect(() async => await cache.deleteUnprotected('1'), throwsException);
    });

    test('Store Entity with Temp ID', () async {
      // Create a mock entity with temp ID
      final entity = MockEntity();
      final tempId = "${ID_TempIDPrefix}1";
      when(entity.id).thenReturn(tempId);
      when(entity.toJson()).thenReturn({'id': tempId, 'data': 'data1'});

      // Store the entity
      await cache.store(entity.id, entity);

      // Check that cacheCheckSums does not contain the temp ID
      HashMap<String, String> cacheCheckStates =
          await cache.getCacheCheckStates();
      expect(cacheCheckStates.containsKey(entity.id), isFalse);

      // cacheSyncFlags should be true
      expect(cache.cacheSyncFlags[entity.id], true);
    });

    test('Store Entity with Different Key and ID', () async {
      // Create a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});

      // Store the entity with a different key
      await cache.store('old_key', entity);

      // Verify that deleteUnprotected was called for 'old_key'
      verify(localStorage.removeItem('old_key')).called(1);

      // Verify that the entity was stored with its own ID
      verify(localStorage.setItem(entity.id, jsonEncode(entity.toJson())))
          .called(1);
    });

    test('Set Cache Sync Flags with Deleted Entity', () async {
      // Create and store a mock entity
      final entity = MockEntity();
      when(entity.id).thenReturn('1');
      when(entity.getChecksum()).thenReturn('checksum1');
      when(entity.toJson()).thenReturn({'id': '1', 'data': 'data1'});

      await cache.store(entity.id, entity);

      // Set cache sync flags indicating the entity is deleted
      HashMap<String, String> serverCheckSums = HashMap();
      serverCheckSums[entity.id] = EntityState.deleted.toString();

      await cache.setCacheSyncFlags(serverCheckSums);

      // The entity should be removed from cache
      verify(localStorage.removeItem(entity.id)).called(1);

      // cacheCheckSums should not contain the entity
      HashMap<String, String> cacheCheckStates =
          await cache.getCacheCheckStates();
      expect(cacheCheckStates.containsKey(entity.id), isFalse);
    });
  });
}
